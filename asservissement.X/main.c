/**
  Generated main.c file from MPLAB Code Configurator

  @Company
    Microchip Technology Inc.

  @File Name
    main.c

  @Summary
    This is the generated main.c using PIC24 / dsPIC33 / PIC32MM MCUs.

  @Description
    This source file provides main entry point for system initialization and application code development.
    Generation Information :
        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.4
        Device            :  dsPIC33EP256MC502
    The generated drivers are tested against the following:
        Compiler          :  XC16 v2.10
        MPLAB 	          :  MPLAB X v6.05
*/

/*
    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
    software and any derivatives exclusively with Microchip products.

    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.

    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.

    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
    TERMS.
*/

////////////////////////////////////////////////////////////////////////////////

/*
 * File generated by MCC then modified by Axel TRÃ‰MAUDANT on October 2023
 * 
 * @Description
 * In this file is the content for enslaving a DC motor used for the robot of 
 * the 2024 edition of the Coupe de France de Robotique.
 * 
 * NOTA: MCC Generated Files have only been modified using MCC
 */

/**
  Section: Included Files
*/
#include "mcc_generated_files/system.h"
#include "mcc_generated_files/tmr1.h"
#include "i2c.h"


/*      Global variables        */

// 12 = nb points coder ; 4 because the QEI mode is x4 ; angle in radians = 0.1309
#define ANGLE_CODER 360.0 / 12.0 / 4.0 * 3.1415926535897932384626433 / 180 
#define TIME_INTERVAL 0.012 // time between two call of interrupt of timer 1 in seconds

// 0.01 == time between 2 calls of the timer interrupt
const float rotating_speed_coef = ANGLE_CODER / TIME_INTERVAL;

int old_position = 0; // Previous position of the encoder

int speed_count = 0; // Sum of the speed
uint8_t speed_measure_count = 0; // Number of times speed_rotation_measure is called

// PID variables
const int kp = 10, ki = 20; const float kd = 0.3; // Coef PID
volatile int previous_error = 0.0, integral = 0.0;
volatile int rotating_speed_target = 0; // rad/s

// Message variables
const uint8_t i2c_address = 0x51;
const uint8_t motor_speed_multiplier = 10; // ANGLE_CODER / TIME_INTERVAL rounded

/*      Initialisation functions       */

/*
 * Initialisation of the PWM 
 */
void init_PWM()
{    
    /* Set PWM Period on Primary Time Base */
    PTPER = 3684; // 500 us

    /* Set Phase Shift */
    PHASE1 = 0;

    /* Set Duty Cycles */
    MDC = 0; // 0 %

    /* Set Dead Time Values */
    DTR1 = 0;
    ALTDTR1 = 0;

    /* Set PWM Mode to Push-Pull, swap for having a 'high' duty cycle
     * and enable only pwm1 on pin RB15
     */
    IOCON1 = 0x4C02;

    /* Set PWM Mode to Independent */
    PWMCON1 =  0x0100;

    /* Configure Faults */
    FCLCON1 = 0x0003;

    /* 1:1 Prescaler */
    PTCON2 = 0x0000;
    
    // Enable only pwm on pin RB15
    IOCON2 = 0;
    IOCON3 = 0;

    /* Enable PWM Module */
    PTCON = 0x8000;
}

/*
 * Initilisation of the QEI
 */
void init_QEI(void)
{
    RPINR14 = 0x2a2b; // Set QEI on RB10 and RB11 (pins 21 and 22)
    POS1CNTL = 0;
    
    // Set parameters
    QEI1CONbits.CCM    = 0; // Counter Control Mode Selection bits set as x4 mode
    QEI1CONbits.INTDIV = 7; // Timer clock prescaler set as 1:128
    QEI1CONbits.IMV    = 0; // Index match value
    QEI1IOCbits.FLTREN = 0; // Deactivate filter
    QEI1CONbits.PIMOD  = 0; // Position counter is unaffected by the Index input
    QEI1IOCbits.SWPAB  = 0; // Don't swap QEA and QEB
    QEI1CONbits.QEIEN  = 1; // Enable QEI module
}


/*      Utilitarian functions       */


/*
 * Set the duty cycle of the PWM
 * @param duty: wanted duty cycle of the pwm
 * 0 <= duty <=1
 */
void set_duty_cycle(float duty)
{
    // duty must be between 0 and 1
    if(duty < 0) duty = 0.0;
    else if(duty > 1) duty = 1.0;
    
    // MDC = Duty cycle register
    // PTPER = Period register
    MDC = PTPER * duty;
}

/*
 * Set the rotating direction of the motor
 * @param clockwise: set the rotating direction of the motor clockwise
 * The rotating direction set here may not be really it depending how the motor is cabled
 */
void set_rotation_clockwise(bool clockwise)
{
    // Set or reset RB12 and RB13 
    LATBbits.LATB12 = clockwise;
    LATBbits.LATB13 = !clockwise;
}

/*
 * Set the rotating speed target of the motor.
 * @param target: wanted rotating speed of the motor, 
 * if <0, the motor rotate in the other direction
 */
void set_rotating_speed_target(int target)
{
    if (target != rotating_speed_target)
    {
        rotating_speed_target = target;

        // Set rotating direction
        set_rotation_clockwise(target > 0);

        // Reset PID variables
        integral = 0;
        previous_error = 0;
    }
}

/*
 * Enslave the motor to rotate at the speed defined by rotating_speed_target
 * depending on the current speed 
 * @param speed: current rotating speed of the motor in rad/s
 * @param time_interval: time between two controls
 */
void control_motor_speed(int speed, float time_interval)
{
    // Calculate the error between the target speed and current speed
    int error = rotating_speed_target - speed;
    
    // Set the error with the right sign
    if(rotating_speed_target < 0 || (rotating_speed_target == 0 && speed < 0)) 
        error = -error;
    
    // Calculate the proportional term
    int proportional = kp * error;
    
    // Calculate the integral term
    integral += ki * error * time_interval;
    
    // Calculate the derivative term
    float derivative = kd * (error - previous_error) / time_interval;
    
    // Change the rotating speed ; 670 is present to put the value between 0 and 1
    set_duty_cycle((float) (proportional + integral + derivative) / 670.0);
    
    previous_error = error; // Update the error
}

/*      Callback functions      */

/*
 * Callback function called by the timer1 interrupts each 12 ms 
 * for calculating the rotating speed of the motor
 */
void speed_rotation_measure()
{    
    int current_position = (int) POS1CNTL; // Get the pulse count
    
    // Calculate the rotating speed in rad/s ; 
    // Around 700 rad/s at max speed
    int rotating_speed = (current_position - old_position) * rotating_speed_coef;
    
    old_position = current_position;
    
    speed_count += rotating_speed;
    speed_measure_count ++;
    
    if(speed_measure_count >= 20) // Check to avoid overflow
    {
        speed_count /= speed_measure_count;
        speed_measure_count = 1;
    }
    
    control_motor_speed(rotating_speed, TIME_INTERVAL); // Enslave
}

/*
                         Main application
 */
int main(void)
{
    // initialize the device
    init_QEI(); // Must be first for UART and CAN communication ; I don't know why 
    SYSTEM_Initialize();
    I2C1_Initialize(i2c_address, motor_speed_multiplier);
    init_PWM();
    
    // Set complementary parameters
    TMR1_SetInterruptHandler(&speed_rotation_measure);

    // I2C parameters
    I2C1_ReadPointerSet(&speed_count, &speed_measure_count);
    I2C1_set_receive_handler(&set_rotating_speed_target);
    
    // Start modules
    TMR1_Start();
    
    while (1)
    {
        // Nothing to do, everything is handled by interrupts 
    }
    
    // If we got here, a problem appeared
    
    return 1; 
}
/**
 End of File
*/
